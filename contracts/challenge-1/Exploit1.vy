# @version ^0.3.7

from vyper.interfaces import ERC20 as IERC20

interface IEulerMarkets:
    def activateMarket(underlying: address) -> address: nonpayable
    def underlyingToEToken(underlying: address) -> address: view
    def underlyingToDToken(underlying: address) -> address: view
    def enterMarket(subAccountId: uint256, newMarket: address): nonpayable
    def exitMarket(subAccountId: uint256, oldMarket: address): nonpayable

interface IEulerDToken:
    def borrow(subAccountId: uint256, amount: uint256): nonpayable
    def balanceOf(account: address) -> uint256: view
    def repay(subAccountId: uint256, amount: uint256): nonpayable

interface IExec:
    def deferLiquidityCheck(account: address, data: Bytes[max_value(uint8)]): nonpayable

interface ICurve:
    def exchange(a: int128, b: int128, c: uint256, d: uint256): nonpayable

interface ICToken:
    def mint(mintAmount: uint256) -> uint256: nonpayable
    def borrow(borrowAmount: uint256) -> uint256: nonpayable

interface IComptroller:
    def enterMarkets(cTokens: DynArray[address, 32]) -> DynArray[uint256, 32]: nonpayable

owner: immutable(address)

COMPTROLLER: constant(address) = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B
CETHER: constant(address) = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5
CDAI: constant(address) = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643
CUSDC: constant(address) = 0x39AA39c021dfbaE8faC545936693aC917d5E7563
ORACLE: constant(address) = 0x65c816077C29b557BEE980ae3cC2dCE80204A0C5

USDC: constant(address) = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 
DAI: constant(address) = 0x6B175474E89094C44Da98b954EedeAC495271d0F

EULER_MARKET: constant(address) = 0x3520d5a913427E6F0D6A83E07ccD4A4da316e4d3
EULER: constant(address) = 0x27182842E098f60e3D576794A5bFFb0777E025d3
EXEC: constant(address) = 0x59828FdF7ee634AaaD3f58B19fDBa3b03E2D9d80

POOL: constant(address) = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7

@external
@payable
def __init__():
    owner = msg.sender

@external
def attack():
    assert msg.sender == owner, "!owner"
    IExec(EXEC).deferLiquidityCheck(self, b"")

@external
def onDeferredLiquidityCheck(encodedData: Bytes[max_value(uint8)]):
    markets: IEulerMarkets = IEulerMarkets(EULER_MARKET)

    borrowed_d_token: IEulerDToken = IEulerDToken(markets.underlyingToDToken(DAI))

    borrowAmount: uint256 = as_wei_value(5_000_000, "ether") # 5 Million DAI

    IEulerDToken(borrowed_d_token.address).borrow(0, borrowAmount)

    # do exploit here

    # repaying borrowed amount
    IERC20(DAI).approve(EULER, max_value(uint256))
    borrowed_d_token.repay(0, max_value(uint256))
